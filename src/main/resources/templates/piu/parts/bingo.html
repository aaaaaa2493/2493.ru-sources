<html lang="en" xmlns:th="http://www.thymeleaf.org">

<div th:fragment="bingo" id="field" class="field">
    <div th:each="row : ${#numbers.sequence(0, rows - 1, 1)}" th:id="${row}" class="row">
        <th:block th:each="col : ${#numbers.sequence(0, columns - 1, 1)}">
            <div th:replace="piu/parts/cell :: cell(${row + '' + col})"></div>
        </th:block>
    </div>

    <script id="song-list" type="text/javascript" th:inline="javascript">
        const songs = [[${songs}]];

        const rows = [[${rows}]];
        const columns = [[${columns}]];
        const width = [[${width}]];
        const height = [[${height}]];
    </script>

    <script id="setup-cells" type="text/javascript" th:inline="javascript">
        const ALL_CELLS = [];
        const cellsToCharts = {};
        const selectedCharts = [];
        const chartIdToChart = {};

        const centerRow = rows / 2 | 0;
        const centerCol = columns / 2 | 0;

        function isCenterNamesCell(row, col) {
            return rows > 1 && columns > 1 && row === centerRow && col === centerCol;
        }

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
                let cellId = r + '' + c;

                if (!isCenterNamesCell(r, c)) {
                    ALL_CELLS.push(cellId);
                    cellsToCharts[cellId] = null;
                }
            }
        }
    </script>

    <script th:if="${isBingo}" type="text/javascript" th:inline="javascript">
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
                let cellId = r + '' + c;
                let cell = document.getElementById(cellId);

                if (isCenterNamesCell(r, c)) {
                    let center = document.getElementById(cellId);
                    center.classList.add("center");
                    cell.innerHTML =
                        '<div id="p1name" class="p1">P1</div>' +
                        '<div id="p2name" class="p2">P2</div>' + cell.innerHTML;
                }
            }
        }
    </script>

    <script th:unless="${altLayout}" type="text/javascript" th:inline="javascript">
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
                let cellId = r + '' + c;
                let cell = document.getElementById(cellId);

                cell.style["width"] = width + "px";
                cell.style["height"] = height + "px";
            }
        }
    </script>


    <script th:if="${altLayout}" src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
    <script th:if="${altLayout}" type="text/javascript" th:inline="javascript">
        {
            let loader = `
                <div id="loader">
                    <div id="loader-bar"></div>
                    <div class="sk-cube-grid">
                        <div class="sk-cube sk-cube-1">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-2">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-3">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-4">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-5">
                            <div class="yellow-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-6">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-7">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-8">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-9">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="back"></div>
                    </div>
                </div>`;

            let elem = document.getElementById("00");
            elem.innerHTML = loader + elem.innerHTML;
        }

        function rs(){
            var WDT = $(".row").width() -45,
                HGH = WDT*3 / 4;

            $("#settings").width(WDT);
            $("hr").width(WDT-30);
            $("#random").width(WDT-30);

            let e = document.getElementById('00');
            e.style["width"] = WDT + "px";
            e.style["height"] = HGH + "px";

        }

        window.addEventListener('load', function(event){
            rs();
        });

        window.addEventListener('resize', function(event){
            rs();
        });

        function loader(){
            $("#loader").css({
                "display":"flex"
            });
            $(".diffname").css({
                "display":"none"
            });

            let updateLoaderFunc = function(){
                if (downloadedImage === null) {
                    $("#loader").css({
                        "display":"none"
                    });
                    $(".diffname").css({
                        "display":"block"
                    });
                    $("#loader-bar").css({
                        "width":"0%"
                    });
                } else {
                    setTimeout(updateLoaderFunc, 10);
                }
            }

            setTimeout(updateLoaderFunc, 2000);
        }
    </script>

    <script type="text/javascript" th:inline="javascript">

        const nonInterestingCls = "non-interesting";
        const determinedCls = "determined";

        const shortened = {
            "Can-can ~Orpheus in The Party Mix~": "Can-Can ~OiTPM~",
            "FOUR SEASONS OF LONELINESS verÎ² feat. sariyajin": "FOUR SEASONS OF LONELINESS",
            "DESTRUCIMATE": "DESTRUCI- MATE",
            "The Quick Brown Fox Jumps Over The Lazy Dog": "TQBFJOTLD",
            "Hypnosis(SynthWulf Mix)": "Hypnosis (SynthWulf Mix)",
            "Nakakapagpabagabag": "Nakakapag- pabagabag"
        }

        const fontchange = {
            "Turkey March -Minimal Tunes-": "21px",
            "Meteo5cience": "21px",
            "Love is a danger zone (try to B.P.M.)": "21px",
            "Reminiscence": "21px",
            "Blaze emotion (Band version)": "21px",
            "Repeatorment Remix": "20px",
            "Indestructible": "21px",
        }


        function isMainDiagonalCell(cellId) {
            return cellId[0] === cellId[1];
        }

        function isSideDiagonalCell(cellId) {
            return Number(cellId[0]) + Number(cellId[1]) === rows - 1;
        }

        function isDiagonalCell(cellId) {
            return isMainDiagonalCell(cellId) || isSideDiagonalCell(cellId);
        }

        function getDiagonalCells(cellId) {
            if (isMainDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isMainDiagonalCell(c));
            } else if (isSideDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isSideDiagonalCell(c));
            }
            return undefined;
        }

        function getSelectedCells() {
            return ALL_CELLS.filter(c => isCellSelected(c));
        }

        function getEmptyCells() {
            return ALL_CELLS.filter(c => isCellEmpty(c));
        }

        function isCellEmpty(cellId) {
            return cellsToCharts[cellId] === null;
        }

        function getInProgressCells() {
            return ALL_CELLS.filter(c => isCellInProgress(c));
        }

        function getCellsToChange() {
            let emptyCells = getEmptyCells();

            if (emptyCells.length > 0) {
                return emptyCells;
            }

            let cellsToChange = getSelectedCells();
            if (cellsToChange.length > 0) {
                return cellsToChange;
            }
            return getInProgressCells();
        }

        function getCandidatesCharts() {
            let candidates = [];

            for (let song of songs) {
                for (let chart of song.charts) {

                    if (selectedCharts.includes(chart.chartId)) {
                        continue;
                    }

                    if (includeMix && !filter_mix(chart.mix)) {
                        continue;
                    }

                    if (includeBpm && !filter_bpm(song.song.bpm)) {
                        continue;
                    }

                    let songCut = song.song.cut;
                    if (includeCut) {
                        if (!filter_cut(songCut)) {
                            continue;
                        }
                        songCut = get_simpler_cut(songCut);
                    }

                    let difficulty = chart.difficulty.difficulty;
                    if (difficulty < minDifficulty || difficulty > maxDifficulty) {
                        continue;
                    }

                    let coop = chart.difficulty.coop;
                    if (coop && !isCoop) {
                        continue;
                    }
                    if (!coop && isCoop) {
                        continue;
                    }

                    let performance = chart.difficulty.performance;
                    if (performance && !isPerformance && !isOnlyPerformance) {
                        continue;
                    }
                    if (!performance && isOnlyPerformance) {
                        continue;
                    }

                    let single = chart.difficulty.single;
                    if (single && !isSingle) {
                        continue;
                    }

                    let double = chart.difficulty.double;
                    if (double && !isDouble) {
                        continue;
                    }

                    candidates.push({
                        name: song.song.name,
                        diff: chart.difficulty.name,
                        diffNum: difficulty,
                        cut: songCut,
                        card: song.song.card,
                        cardBig: song.song.cardBig,
                        chartId: chart.chartId,
                        single: single,
                        double: double,
                        performance: performance,
                        coop: coop,
                    });
                }
            }

            return candidates;
        }

        function shuffleCells(cells) {
            return cells
                .map(value => ({ value, sort: Math.random() }))
                .sort((a, b) => a.sort - b.sort)
                .map(({ value }) => value);
        }

        function getChartFromCell(cellId) {
            return chartIdToChart[ cellsToCharts[cellId] ];
        }

        function getChartsFromCells(cellsIds) {
            return cellsIds
                .map(c => cellsToCharts[c])
                .filter(c => c !== null)
                .map(c => chartIdToChart[c]);
        }

        function getCellsSameRow(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && c[0] === cellId[0]);
        }

        function getCellsSameCol(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && c[1] === cellId[1]);
        }

        function doesMakeSameLine(cellId, wantSingle) {
            let sameRowCells = getCellsSameRow(cellId);
            let sameRowCharts = getChartsFromCells(sameRowCells);

            if (sameRowCells.length === sameRowCharts.length &&
                sameRowCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                return true;
            }

            let sameColCells = getCellsSameCol(cellId);
            let sameColCharts = getChartsFromCells(sameColCells);

            if (sameColCells.length === sameColCharts.length &&
                sameColCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                return true;
            }

            if (isDiagonalCell(cellId)) {
                let sameDiagonalCells = getDiagonalCells(cellId);
                let sameDiagonalCharts = getChartsFromCells(sameDiagonalCells);

                if (sameDiagonalCells.length === sameDiagonalCharts.length &&
                    sameDiagonalCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                    return true;
                }
            }

            return false;
        }

        function haveSameLineOnTable() {
            return ALL_CELLS.some(c => c !== null && doesMakeSameLine(c, getChartsFromCells([c])[0].single));
        }

        function chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles) {
            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, true)) {
                return false;
            }
            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, false)) {
                return true;
            }

            let totalSum = sumSingles + sumDoubles;
            let currSinglePercentage;
            let currDoublePercentage;

            if (totalSum === 0) {
                currSinglePercentage = 0.5;
                currDoublePercentage = 0.5;
            } else {
                currSinglePercentage = sumSingles / totalSum;
                currDoublePercentage = sumDoubles / totalSum;
            }

            // returns true if chooses Singles, returns false if chooses Doubles
            return currSinglePercentage < singlePercentage;

            //let diffPercentage = currSinglePercentage - currDoublePercentage;

            //let improvedSinglePercentage = singlePercentage - diffPercentage;
            //let randomSingleDouble = Math.random();

            // returns true if chooses Singles, returns false if chooses Doubles
            //return improvedSinglePercentage > randomSingleDouble;
        }

        function chooseDifficulty(sumDiff, sumAllDiff) {
            let updatedPercentagesDifficulties = {};
            for (let currDiff in sumDiff) {
                if (sumAllDiff === 0) {
                    updatedPercentagesDifficulties[currDiff] = percents[currDiff];
                    continue;
                }

                let currDiffPercentage = sumDiff[currDiff] / sumAllDiff;
                let percentageDifference = currDiffPercentage - percents[currDiff];
                updatedPercentagesDifficulties[currDiff] = percents[currDiff] - percentageDifference;
            }

            while (true) {
                let randomDifficulty = Math.random();

                for (let currDiff in updatedPercentagesDifficulties) {
                    let currPercents = updatedPercentagesDifficulties[currDiff];
                    randomDifficulty -= currPercents;
                    if (randomDifficulty < 0) {
                        return Number(currDiff);
                    }
                }
            }
        }

        function filterCandidates(candidates, searchSingles, searchDoubles, chosenDifficulty) {
            let nonSelectedCandidates = candidates
                .filter(c => !selectedCharts.includes(c.chartId));

            let filteredCandidates = nonSelectedCandidates
                .filter(c =>
                    (c.single && searchSingles || c.double && searchDoubles) &&
                    c.diffNum === chosenDifficulty ||
                    c.coop
                );

            if (filteredCandidates.length === 0) {
                filteredCandidates = nonSelectedCandidates
            }

            return filteredCandidates;
        }

        function randomize() {
            let cellsToChange = shuffleCells(getCellsToChange());
            let candidates = getCandidatesCharts();

            let sumSingles = 0;
            let sumDoubles = 0;
            let sumDiff = {};
            let sumAllDiff = 0;
            for (let perc in percents) {
                sumDiff[perc] = 0;
            }

            let cannotRandomizeCellSameLine = false;

            for (let cellId of cellsToChange) {
                if (candidates.length === 0) {
                    return;
                }

                let searchSingles = isSingle;
                let searchDoubles = isDouble;

                if (isCoop) {
                    searchSingles = false;
                    searchDoubles = false;
                }

                if (isNoSameLineSupported && isNoSameLine) {
                    if (isSingle && doesMakeSameLine(cellId, true) &&
                        isDouble && doesMakeSameLine(cellId, false)) {
                        cannotRandomizeCellSameLine = true;
                        continue;
                    }
                }

                if (isSingle && isDouble) {
                    searchSingles = chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles);
                    searchDoubles= !searchSingles;
                } else if (isNoSameLineSupported && isNoSameLine) {
                    if (isSingle && !isDouble && doesMakeSameLine(cellId, true) ||
                        isDouble && !isSingle && doesMakeSameLine(cellId, false)) {
                        cannotRandomizeCellSameLine = true;
                        continue;
                    }
                }

                let chosenDifficulty = chooseDifficulty(sumDiff, sumAllDiff);

                let newerCandidates = filterCandidates(
                    candidates, searchSingles, searchDoubles, chosenDifficulty);

                if (newerCandidates.length === 0) {
                    break;
                }

                let itemIndex = Math.floor(Math.random() * newerCandidates.length);
                let item = newerCandidates[itemIndex];

                if (item.single) {
                    sumSingles++;
                }

                if (item.double) {
                    sumDoubles++;
                }

                sumAllDiff++;
                if (item.diffNum in sumDiff) {
                    sumDiff[item.diffNum]++;
                }

                writeChartInfoToCell(cellId, item);
            }

            if (initialRandomize && cannotRandomizeCellSameLine) {
                clearTable();
                randomize();
                return;
            }

            if (initialRandomize) {
                document.getElementById("random").innerHTML = afterRandomizeText;
                initialRandomize = false;
            }

            if (isNoSameLineSupported) {
                handleRedNoSameLineText(cannotRandomizeCellSameLine);
            }

            lockIrrelevantCells();
            determineNotInterestingCells();

            console.log(ALL_CELLS.filter(c => getChartFromCell(c).single).length, ALL_CELLS.filter(c => getChartFromCell(c).double).length);
        }

        function clicked(cellId) {
            let songname = document.getElementById(cellId + "song");
            if (songname.innerHTML === '') {
                return;
            }

            let selectedDiv = document.getElementById(cellId + "selected");

            if (selectedDiv.style.display === 'block') {
                selectedDiv.style.display = '';
            } else {
                selectedDiv.style.display = 'block';
            }

            determineNotInterestingCells();
        }

        function isCellSelected(cellId) {
            let selected = document.getElementById(cellId + "selected");
            return selected.style.display === 'block';
        }

        function isCellInProgress(cellId) {
            let inprogress = document.getElementById(cellId + "inprogress");
            return inprogress.style.display === 'block';
        }

        function isCellLocked(cellId) {
            let lock = document.getElementById(cellId + "lock");
            return lock.style.display === 'block';
        }

        function lockCell(cellId) {
            let lock = document.getElementById(cellId + "lock");
            lock.style.display = 'block';

            let cell = document.getElementById(cellId);
            cell.classList.add("locked");
        }

        function unlockCell(cellId) {
            let lock = document.getElementById(cellId + "lock");
            lock.style.display = '';

            let cell = document.getElementById(cellId);
            cell.classList.remove("locked");
        }

        function isCellHasResult(cellId) {
            let blue = document.getElementById(cellId + "bluewin");
            let red = document.getElementById(cellId + "redwin");
            let draw = document.getElementById(cellId + "draw");

            return blue.style.display === 'block'
                || red.style.display === 'block'
                || draw.style.display === 'block';
        }

        function isCellBlueWin(cellId) {
            let blue = document.getElementById(cellId + "bluewin");
            return blue.style.display === 'block';
        }

        function isCellRedWin(cellId) {
            let red = document.getElementById(cellId + "redwin");
            return red.style.display === 'block';
        }

        function resetCell(cellId) {
            unlockCell(cellId);

            let cell = document.getElementById(cellId);
            cell.classList.remove(determinedCls);
            cell.classList.remove(nonInterestingCls);

            let blue = document.getElementById(cellId + "bluewin");
            let red = document.getElementById(cellId + "redwin");
            let draw = document.getElementById(cellId + "draw");
            let selected = document.getElementById(cellId + "selected");
            let inprogress = document.getElementById(cellId + "inprogress");
            let lock = document.getElementById(cellId + "lock");

            for (let item of [blue, red, draw, selected, inprogress, lock]) {
                if (item.style.display === 'block') {
                    item.style.display = '';
                }
            }
        }

        function changeCellState(cls) {
            let foundSelected = false;
            const isDetermination = ['redwin', 'bluewin', 'draw'].includes(cls);

            for (let cellId of ALL_CELLS) {
                if (!isCellSelected(cellId)) {
                    continue;
                }

                foundSelected = true;

                resetCell(cellId);

                if (cls) {
                    document.getElementById(cellId + cls).style.display = 'block';

                    if (isDetermination) {
                        document.getElementById(cellId).classList.add(determinedCls);
                    }
                }
            }

            if (!foundSelected && isDetermination) {
                for (let cellId of ALL_CELLS) {
                    if (isCellInProgress(cellId)) {
                        resetCell(cellId);
                        document.getElementById(cellId + cls).style.display = 'block';
                        document.getElementById(cellId).classList.add(determinedCls);
                    }
                }
            }

            outerIf:
            if (!foundSelected && cls === 'inprogress' &&
                ALL_CELLS.every(c => !isCellInProgress(c))) {

                let availableCells = ALL_CELLS
                    .filter(c => !isCellEmpty(c) && !isCellHasResult(c) && !isCellLocked(c));

                if (availableCells.length === 0) {
                    break outerIf;
                }

                let itemIndex = Math.floor(Math.random() * availableCells.length);
                let item = availableCells[itemIndex];

                document.getElementById(item + "inprogress").style.display = 'block';
            }

            if (!foundSelected && cls === 'reset' && ALL_CELLS.some(c => isCellInProgress(c))) {
                for (let cell of getInProgressCells()) {
                    resetCell(cell);
                }
            }

            lockIrrelevantCells();
            determineNotInterestingCells();
        }

        function determineNotInterestingCells() {
            let interestingCells = getSelectedCells() + getInProgressCells();

            for (let cellId of ALL_CELLS) {
                let cell = document.getElementById(cellId);

                if (interestingCells.length === 0) {
                    cell.classList.remove(nonInterestingCls)
                    continue;
                }

                if (!isCellSelected(cellId) && !isCellInProgress(cellId) && !isCellHasResult(cellId)) {
                    cell.classList.add(nonInterestingCls);
                } else {
                    cell.classList.remove(nonInterestingCls);
                }
            }
        }

        function lockIrrelevantCells() {
            if (!isLockingSupported || !isLockCharts) {
                return;
            }

            for (let cellId of ALL_CELLS) {
                if (isCellLocked(cellId)) {
                    unlockCell(cellId);
                }

                if (isCellEmpty(cellId) ||
                    isCellHasResult(cellId) ||
                    isCellInProgress(cellId)) {
                    continue;
                }

                let rowLock = false;
                let colLock = false;
                let diagLock = false;

                let sameRow = getCellsSameRow(cellId);

                if (sameRow.some(c => isCellBlueWin(c)) &&
                    sameRow.some(c => isCellRedWin(c))) {
                    rowLock = true;
                }

                let sameCol = getCellsSameCol(cellId);

                if (sameCol.some(c => isCellBlueWin(c)) &&
                    sameCol.some(c => isCellRedWin(c))) {
                    colLock = true;
                }

                if (isDiagonalCell(cellId)) {
                    let diagonalCells = getDiagonalCells(cellId);

                    if (diagonalCells.some(c => isCellBlueWin(c)) &&
                        diagonalCells.some(c => isCellRedWin(c))) {
                        diagLock = true;
                    }
                } else {
                    diagLock = true;
                }

                if (rowLock && colLock && diagLock) {
                    lockCell(cellId);
                }
            }
        }

        function unlockAllCells() {
            ALL_CELLS
                .filter(c => isCellLocked(c))
                .forEach(c => unlockCell(c));
        }

        let downloadedImage = null;
        let downloadStart = null;

        function writeChartInfoToCell(cellId, chart) {
            makeNewCell(cellId);

            let cell = document.getElementById(cellId);
            let songname = document.getElementById(cellId + "song");
            let cutname = document.getElementById(cellId + "cut");
            let diffname = document.getElementById(cellId + "diff");

            let name = chart.name;
            if (name in shortened) {
                name = shortened[name];
            }

            songname.innerHTML = name;
            songname.style['font-size'] = '';

            if (chart.name in fontchange) {
                songname.style['font-size'] = fontchange[chart.name];
            }

            cutname.innerHTML = chart.cut;
            diffname.innerHTML = chart.diff;

            if (chart.single) {
                diffname.classList.add("single");
            }
            if (chart.double) {
                diffname.classList.add("double");
            }
            if (chart.performance) {
                diffname.classList.add("performance");
            }
            if (chart.coop) {
                diffname.classList.add("coop");
            }

            let card = useHighResImages ? chart.cardBig : chart.card;

            cell.style['background-image'] = "url(" + card + ")";
            downloadedImage = card;
            downloadStart = Date.now();

            selectedCharts.push(chart.chartId);
            cellsToCharts[cellId] = chart.chartId;
            chartIdToChart[chart.chartId] = chart;
        }

        function makeNewCell(cellId) {
            resetCell(cellId);

            let cell = document.getElementById(cellId);
            let songname = document.getElementById(cellId + "song");
            let cutname = document.getElementById(cellId + "cut");
            let diffname = document.getElementById(cellId + "diff");

            diffname.classList.remove("single");
            diffname.classList.remove("double");
            diffname.classList.remove("performance");
            diffname.classList.remove("coop");

            if (songname.innerHTML === '') {
                return;
            }

            let chartId = cellsToCharts[cellId];
            selectedCharts.splice(selectedCharts.indexOf(chartId), 1);
            cellsToCharts[cellId] = null;

            songname.innerHTML = '';
            songname.style['font-size'] = '';
            cutname.innerHTML = '';
            diffname.innerHTML = '';
            cell.style['background-image'] = "";
        }

        function clearTable() {
            resetSettings();

            for (let cellId of ALL_CELLS) {
                makeNewCell(cellId);
            }
        }

    </script>

</div>