<html lang="en" xmlns:th="http://www.thymeleaf.org">

<div th:fragment="bingo">

    <div id="field" class="field"></div>

    <script id="song-list" type="text/javascript" th:inline="javascript">
        let songs = [];
        const mixes = [[${mixes}]];
        const defaultMix = [[${defaultMix}]];

        let rows = [[${rows}]];
        let columns = [[${columns}]];
        let width = [[${width}]];
        let height = [[${height}]];
    </script>

    <script id="basic-functions" type="text/javascript">
        const BLUE_WIN = "bluewin";
        const RED_WIN = "redwin";
        const DRAW = "draw";
        const SELECTED = "selected";
        const IN_PROGRESS = "inprogress";
        const LOCKED = "lock";

        const TYPE_NAMES = "names";
        const NAMES_PLAYER_1 = "p1name";
        const NAMES_PLAYER_2 = "p2name";

        const TYPE_RANDOM = "info";
        const RANDOM_SONG = "song";
        const RANDOM_CUT = "cut";
        const RANDOM_DIFFICULTY = "diff";

        const OVERLAYS = [
            BLUE_WIN,
            RED_WIN,
            DRAW,
            SELECTED,
            IN_PROGRESS,
            LOCKED,
        ];

        const CELL_TYPES = [
            TYPE_NAMES,
            TYPE_RANDOM,
        ];

        function isShowingBlock(block) {
            return block.style.display === 'block' || block.style.display === 'flex'
        }

        function showBlock(block) {
            if (CELL_TYPES.some(e => block.id.endsWith(e))) {
                let cellId = extractCellId(block.id);
                CELL_TYPES.forEach(e => hideBlock(getBlock(cellId, e)));
            }

            if (block.id.endsWith(RED_WIN) ||
                block.id.endsWith(BLUE_WIN)
            ) {
                block.style.display = 'flex';
            } else {
                block.style.display = 'block';
            }
        }

        function byId(cellId, addon) {
            if (addon) {
                return document.getElementById(getBlockId(cellId, addon));
            }
            return document.getElementById(cellId);
        }

        function hideBlock(block) {
            block.style.display = '';
        }

        function getBlock(cellId, addon) {
            return byId(getBlockId(cellId, addon));
        }

        function getBlockId(cellId, addon) {
            return `${cellId}-${addon}`;
        }

        function getCell(row, col) {
            return byId(getCellId(row, col));
        }

        function getCellId(row, col) {
            return `${row}-${col}`;
        }

        function extractCellId(blockId) {
            let parts = blockId.split('-');
            return parts.slice(0, 2).join('-');
        }

        function getCellRow(cellId) {
            return parseInt(cellId.split('-')[0], 10);
        }

        function getCellColumn(cellId) {
            return parseInt(cellId.split('-')[1], 10);
        }
    </script>

    <script id="generate-cells" type="text/javascript" th:inline="javascript">

        function generateField() {
            let fieldHtml = ``;

            for (let row = 0; row < rows; row++) {
                fieldHtml += `<div id="${row}" class="row">`;

                for (let col = 0; col < columns; col++) {
                    let cellId = getCellId(row, col);
                    fieldHtml += `
                        <div id="${cellId}" class="cell" onclick="clicked(this.id)">
                            <div id="${getBlockId(cellId, TYPE_NAMES)}" class="filler players_names">
                                <div id="${getBlockId(cellId, NAMES_PLAYER_1)}" class="p1"></div>
                                <div id="${getBlockId(cellId, NAMES_PLAYER_2)}" class="p2"></div>
                            </div>

                            <div id="${getBlockId(cellId, BLUE_WIN)}" class="filler blue"></div>
                            <div id="${getBlockId(cellId, RED_WIN)}" class="filler red"></div>
                            <div id="${getBlockId(cellId, DRAW)}" class="filler draw"></div>
                            <div id="${getBlockId(cellId, SELECTED)}" class="filler selected"></div>
                            <div id="${getBlockId(cellId, IN_PROGRESS)}" class="filler inprogress"></div>
                            <div id="${getBlockId(cellId, LOCKED)}" class="filler lock"></div>

                            <div id="${getBlockId(cellId, TYPE_RANDOM)}" class="filler cellinfo">
                                <div id="${getBlockId(cellId, RANDOM_SONG)}" class="songname"></div>
                                <div id="${getBlockId(cellId, RANDOM_CUT)}" class="cutname"></div>
                                <div id="${getBlockId(cellId, RANDOM_DIFFICULTY)}" class="diffname"></div>
                            </div>
                        </div>
                    `;
                }

                fieldHtml += `</div>`;
            }

            byId("field").innerHTML = fieldHtml;
        }

        generateField();
    </script>

    <script id="setup-cells" type="text/javascript" th:inline="javascript">
        const ALL_CELLS = [];
        const cellsToCharts = {};
        const selectedCharts = [];
        const chartIdToChart = {};

        const centerRow = rows / 2 | 0;
        const centerCol = columns / 2 | 0;

        function isCenterNamesCell(row, col) {
            return rows > 1 && columns > 1 && row === centerRow && col === centerCol;
        }

        function clearCellObjects() {
            ALL_CELLS.length = 0;
            selectedCharts.length = 0;

            for (const key in cellsToCharts) {
                if (cellsToCharts.hasOwnProperty(key)) {
                    delete cellsToCharts[key];
                }
            }

            for (const key in chartIdToChart) {
                if (chartIdToChart.hasOwnProperty(key)) {
                    delete chartIdToChart[key];
                }
            }
        }

        function generateCellObjects() {
            clearCellObjects();

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < columns; c++) {
                    let cellId = getCellId(r, c);

                    if (!isCenterNamesCell(r, c)) {
                        ALL_CELLS.push(cellId);
                        cellsToCharts[cellId] = null;
                    }
                }
            }
        }

        generateCellObjects();
    </script>

    <script th:if="${isBingo}" type="text/javascript" th:inline="javascript">
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
                let cellId = getCellId(r, c);

                if (isCenterNamesCell(r, c)) {
                    showBlock(byId(cellId, TYPE_NAMES));
                } else {
                    showBlock(byId(cellId, TYPE_RANDOM));
                }
            }
        }
    </script>

    <script th:unless="${altLayout}" type="text/javascript" th:inline="javascript">
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
                let cell = getCell(r, c);

                cell.style.width = width + "px";
                cell.style.height = height + "px";

                let fillerElements = document.querySelectorAll('.filler');
                fillerElements.forEach(e => e.style.width = width + "px");
                fillerElements.forEach(e => e.style.height = height + "px");
            }
        }
    </script>


    <script th:if="${altLayout}" src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
    <script th:if="${altLayout}" type="text/javascript" th:inline="javascript">
        {
            let loader = `
                <div id="loader">
                    <div id="loader-bar"></div>
                    <div class="sk-cube-grid">
                        <div class="sk-cube sk-cube-1">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-2">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-3">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-4">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-5">
                            <div class="yellow-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-6">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-7">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-8">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-9">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="back"></div>
                    </div>
                </div>`;

            let elem = getCell(0, 0);
            elem.innerHTML = loader + elem.innerHTML;
        }

        function rs() {
            let WDT = $(".row").width() -45,
                HGH = WDT*9 / 16;

            $("#settings").width(WDT);
            $("hr").width(WDT-30);
            $("#random").width(WDT-30);

            let e = getCell(0, 0);
            e.style["width"] = WDT + "px";
            e.style["height"] = HGH + "px";
        }

        window.addEventListener('load', rs);
        window.addEventListener('resize', rs);

        function loader(){
            if (includeNoLoader && isNoLoader) {
                return;
            }

            $("#loader").css({
                "display":"flex"
            });
            $(".diffname").css({
                "display":"none"
            });

            let updateLoaderFunc = function(){
                if (downloadedImage === null) {
                    $("#loader").css({
                        "display":"none"
                    });
                    $(".diffname").css({
                        "display":"block"
                    });
                    $("#loader-bar").css({
                        "width":"0%"
                    });
                } else {
                    setTimeout(updateLoaderFunc, 10);
                }
            }

            setTimeout(updateLoaderFunc, 2000);
        }
    </script>

    <script type="text/javascript" th:inline="javascript">

        const nonInterestingCls = "non-interesting";
        const determinedCls = "determined";

        const shortened = {
            "Can-can ~Orpheus in The Party Mix~": "Can-Can ~OiTPM~",
            "FOUR SEASONS OF LONELINESS verÎ² feat. sariyajin": "FOUR SEASONS OF LONELINESS",
            "DESTRUCIMATE": "DESTRUCI- MATE",
            "The Quick Brown Fox Jumps Over The Lazy Dog": "TQBFJOTLD",
            "Hypnosis(SynthWulf Mix)": "Hypnosis (SynthWulf Mix)",
            "Nakakapagpabagabag": "Nakakapag- pabagabag",
            "Pneumonoultramicroscopicsilicovolcanoconiosis": "Pneumonoultra microscopicsilico volcanoconiosis",
        }

        const fontchange = {
            "Turkey March -Minimal Tunes-": "21px",
            "Meteo5cience": "21px",
            "Love is a danger zone (try to B.P.M.)": "21px",
            "Reminiscence": "21px",
            "Blaze emotion (Band version)": "21px",
            "Repeatorment Remix": "20px",
            "Indestructible": "21px",
            "Pneumonoultramicroscopicsilicovolcanoconiosis": "17px",
            "GOODBOUNCE": "20px",
        }


        function isMainDiagonalCell(cellId) {
            return cellId[0] === cellId[1];
        }

        function isSideDiagonalCell(cellId) {
            return Number(cellId[0]) + Number(cellId[1]) === rows - 1;
        }

        function isDiagonalCell(cellId) {
            return isMainDiagonalCell(cellId) || isSideDiagonalCell(cellId);
        }

        function getDiagonalCells(cellId) {
            if (isMainDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isMainDiagonalCell(c));
            } else if (isSideDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isSideDiagonalCell(c));
            }
            return undefined;
        }

        function getSelectedCells() {
            return ALL_CELLS.filter(c => isCellSelected(c));
        }

        function getEmptyCells() {
            return ALL_CELLS.filter(c => isCellEmpty(c));
        }

        function isCellEmpty(cellId) {
            return cellsToCharts[cellId] === null;
        }

        function getInProgressCells() {
            return ALL_CELLS.filter(c => isCellInProgress(c));
        }

        function getCellsToChange() {
            let cellsToChange = getSelectedCells();
            if (cellsToChange.length > 0) {
                return cellsToChange;
            }

            let emptyCells = getEmptyCells();

            if (emptyCells.length > 0) {
                return emptyCells;
            }
            return getInProgressCells();
        }

        function getCandidatesCharts(for_preview) {
            let candidates = [];

            for (let song of songs) {
                next_chart:
                for (let chart of song.charts) {
                    if (!for_preview) {
                        if (selectedCharts.includes(chart.chart_id)) {
                            continue;
                        }
                    }

                    for (let filter of chartFilters) {
                        if (!filter(song, chart)) {
                            continue next_chart;
                        }
                    }

                    candidates.push({
                        songId: song.song_id,
                        chartId: chart.chart_id,
                        name: song.name,
                        diff: chart.difficulty.name,
                        diffNum: chart.difficulty.difficulty,
                        cut: includeCut ? get_simpler_cut(song.cut) : song.cut,
                        card: song.card,
                        cardBig: song.card_big,
                        single: chart.difficulty.single,
                        double: chart.difficulty.double,
                        performance: chart.difficulty.performance,
                        coop: chart.difficulty.coop,
                    });
                }
            }

            return candidates;
        }

        function shuffleCells(cells) {
            return cells
                .map(value => ({ value, sort: Math.random() }))
                .sort((a, b) => a.sort - b.sort)
                .map(({ value }) => value);
        }

        function hasChartInCell(cellId) {
            return !!cellsToCharts[cellId];
        }

        function getChartFromCell(cellId) {
            return chartIdToChart[cellsToCharts[cellId]];
        }

        function getChartsFromCells(cellsIds) {
            return cellsIds
                .map(c => cellsToCharts[c])
                .filter(c => c !== null)
                .map(c => chartIdToChart[c]);
        }

        function getCellsSameRow(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && getCellRow(c) === getCellRow(cellId));
        }

        function getCellsSameCol(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && getCellColumn(c) === getCellColumn(cellId));
        }

        function doesMakeSameLine(cellId, wantSingle) {
            let sameRowCells = getCellsSameRow(cellId);
            let sameRowCharts = getChartsFromCells(sameRowCells);

            if (sameRowCells.length === sameRowCharts.length &&
                sameRowCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                return true;
            }

            let sameColCells = getCellsSameCol(cellId);
            let sameColCharts = getChartsFromCells(sameColCells);

            if (sameColCells.length === sameColCharts.length &&
                sameColCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                return true;
            }

            if (isDiagonalCell(cellId)) {
                let sameDiagonalCells = getDiagonalCells(cellId);
                let sameDiagonalCharts = getChartsFromCells(sameDiagonalCells);

                if (sameDiagonalCells.length === sameDiagonalCharts.length &&
                    sameDiagonalCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                    return true;
                }
            }

            return false;
        }

        function haveSameLineOnTable() {
            return ALL_CELLS.some(c => c !== null && hasChartInCell(c) && doesMakeSameLine(c, getChartFromCell(c).single));
        }

        function chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles) {
            const simplePercents = true;

            if (simplePercents) {
                let totalSum = sumSingles + sumDoubles;
                if (totalSum === 0) {
                    return Math.random() > 0.5;
                } else {
                    let currDoublePercentage = sumDoubles / totalSum;
                    return currDoublePercentage > 0.5;
                }
            }


            // more complex algo, seems to be worse

            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, true)) {
                return false;
            }
            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, false)) {
                return true;
            }

            let totalSum = sumSingles + sumDoubles;
            let currSinglePercentage;
            let currDoublePercentage;

            if (totalSum === 0) {
                currSinglePercentage = 0.5;
                currDoublePercentage = 0.5;
            } else {
                currSinglePercentage = sumSingles / totalSum;
                currDoublePercentage = sumDoubles / totalSum;
            }

            let diffPercentage = currSinglePercentage - currDoublePercentage;

            let improvedSinglePercentage = singlePercentage - diffPercentage;

            let randomSingleDouble = Math.random();

            // returns true if chooses Singles, returns false if chooses Doubles
            return improvedSinglePercentage > randomSingleDouble;
        }

        function chooseDifficulty(sumDiff, sumAllDiff) {
            let updatedPercentagesDifficulties = {};
            for (let currDiff in sumDiff) {
                if (sumAllDiff === 0) {
                    updatedPercentagesDifficulties[currDiff] = percents[currDiff];
                    continue;
                }

                let currDiffPercentage = sumDiff[currDiff] / sumAllDiff;
                let percentageDifference = currDiffPercentage - percents[currDiff];
                updatedPercentagesDifficulties[currDiff] = percents[currDiff] - percentageDifference;
            }

            while (true) {
                let randomDifficulty = Math.random();

                for (let currDiff in updatedPercentagesDifficulties) {
                    let currPercents = updatedPercentagesDifficulties[currDiff];
                    randomDifficulty -= currPercents;
                    if (randomDifficulty < 0) {
                        return Number(currDiff);
                    }
                }
            }
        }

        function filterCandidates(candidates, searchSingles, searchDoubles, chosenDifficulty) {
            let nonSelectedCandidates = candidates
                .filter(c => !selectedCharts.includes(c.chartId));

            let filteredCandidates = nonSelectedCandidates
                .filter(c =>
                    (c.single && searchSingles || c.double && searchDoubles) &&
                    c.diffNum === chosenDifficulty ||
                    c.coop
                );

            if (filteredCandidates.length === 0) {
                filteredCandidates = nonSelectedCandidates
            }

            return filteredCandidates;
        }

        function randomize() {
            let cellsToChange = shuffleCells(getCellsToChange());
            let candidates = getCandidatesCharts(false);

            let sumSingles = 0;
            let sumDoubles = 0;
            let sumDiff = {};
            let sumAllDiff = 0;
            for (let perc in percents) {
                sumDiff[perc] = 0;
            }

            let cannotRandomizeCellSameLine = false;
            let randomizedCharts = [];

            for (let cellId of cellsToChange) {
                if (candidates.length === 0) {
                    return;
                }

                let searchSingles = isSingle;
                let searchDoubles = isDouble;

                if (isCoop) {
                    searchSingles = false;
                    searchDoubles = false;
                }

                if (isNoSameLineSupported && isNoSameLine) {
                    if (isSingle && doesMakeSameLine(cellId, true) &&
                        isDouble && doesMakeSameLine(cellId, false)) {
                        cannotRandomizeCellSameLine = true;
                        continue;
                    }
                }

                if (isSingle && isDouble) {
                    searchSingles = chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles);
                    searchDoubles= !searchSingles;
                } else if (isNoSameLineSupported && isNoSameLine) {
                    if (isSingle && !isDouble && doesMakeSameLine(cellId, true) ||
                        isDouble && !isSingle && doesMakeSameLine(cellId, false)) {
                        cannotRandomizeCellSameLine = true;
                        continue;
                    }
                }

                let chosenDifficulty = chooseDifficulty(sumDiff, sumAllDiff);

                let newerCandidates = filterCandidates(
                    candidates, searchSingles, searchDoubles, chosenDifficulty);

                if (newerCandidates.length === 0) {
                    break;
                }

                let itemIndex = Math.floor(Math.random() * newerCandidates.length);
                let item = newerCandidates[itemIndex];

                if (item.single) {
                    sumSingles++;
                }

                if (item.double) {
                    sumDoubles++;
                }

                sumAllDiff++;
                if (item.diffNum in sumDiff) {
                    sumDiff[item.diffNum]++;
                }

                writeChartInfoToCell(cellId, item);
                randomizedCharts.push(item);
            }

            if (initialRandomize && cannotRandomizeCellSameLine) {
                clearTable();
                randomize();
                return;
            }

            if (initialRandomize && isNoSameLineSupported && isNoSameLine && haveSameLineOnTable()) {
                clearTable();
                randomize();
                return;
            }

            if (initialRandomize) {
                byId("random").innerHTML = afterRandomizeText;
                initialRandomize = false;
            }

            if (isNoSameLineSupported) {
                handleRedNoSameLineText(cannotRandomizeCellSameLine);
            }

            lockIrrelevantCells();
            determineNotInterestingCells();

            for (let chart of randomizedCharts) {
                if (includeNoRepeat) {
                    process_no_repeat(chart);
                }
                if (includePreview) {
                    update_preview(getCandidatesCharts(true));
                }
            }
        }

        function clicked(cellId) {
            let selectedDiv = byId(cellId, SELECTED);

            if (isShowingBlock(selectedDiv)) {
                hideBlock(selectedDiv);
            } else {
                showBlock(selectedDiv);
            }

            determineNotInterestingCells();
        }

        function isCellSelected(cellId) {
            let selected = byId(cellId, SELECTED);
            return isShowingBlock(selected);
        }

        function isCellInProgress(cellId) {
            let inprogress = byId(cellId, IN_PROGRESS);
            return isShowingBlock(inprogress);
        }

        function isCellLocked(cellId) {
            let lock = byId(cellId, LOCKED);
            return isShowingBlock(lock);
        }

        function lockCell(cellId) {
            let lock = byId(cellId, LOCKED);
            showBlock(lock);

            let cell = byId(cellId);
            cell.classList.add("locked");
        }

        function unlockCell(cellId) {
            let lock = byId(cellId, LOCKED);
            hideBlock(lock);

            let cell = byId(cellId);
            cell.classList.remove("locked");
        }

        function isCellHasResult(cellId) {
            let blue = byId(cellId, BLUE_WIN);
            let red = byId(cellId, RED_WIN);
            let draw = byId(cellId, DRAW);
            return isShowingBlock(blue) || isShowingBlock(red) || isShowingBlock(draw);
        }

        function isCellBlueWin(cellId) {
            let blue = byId(cellId, BLUE_WIN);
            return isShowingBlock(blue);
        }

        function isCellRedWin(cellId) {
            let red = byId(cellId, RED_WIN);
            return isShowingBlock(red);
        }

        function resetCell(cellId) {
            unlockCell(cellId);

            let cell = byId(cellId);
            cell.classList.remove(determinedCls);
            cell.classList.remove(nonInterestingCls);

            for (let overlay of OVERLAYS) {
                let item = byId(cellId, overlay);
                if (isShowingBlock(item)) {
                    hideBlock(item);
                }
            }
        }

        function changeCellState(cls) {
            let foundSelected = false;
            const isDetermination = [RED_WIN, BLUE_WIN, DRAW].includes(cls);

            for (let cellId of ALL_CELLS) {
                if (!isCellSelected(cellId)) {
                    continue;
                }

                foundSelected = true;

                resetCell(cellId);

                if (cls !== 'reset') {
                    if (combineInProgressAndSelected && cls === IN_PROGRESS) {
                        showBlock(byId(cellId, SELECTED));
                    } else {
                        showBlock(byId(cellId, cls));
                    }

                    if (isDetermination) {
                        byId(cellId).classList.add(determinedCls);
                    }
                }
            }

            if (!foundSelected && isDetermination) {
                for (let cellId of ALL_CELLS) {
                    if (isCellInProgress(cellId)) {
                        resetCell(cellId);
                        showBlock(byId(cellId, cls));
                        byId(cellId).classList.add(determinedCls);
                    }
                }
            }

            outerIf:
            if (!foundSelected && cls === IN_PROGRESS &&
                ALL_CELLS.every(c => !isCellInProgress(c))) {

                let availableCells = ALL_CELLS
                    .filter(c => !isCellEmpty(c) && !isCellHasResult(c) && !isCellLocked(c));

                if (availableCells.length === 0) {
                    break outerIf;
                }

                let itemIndex = Math.floor(Math.random() * availableCells.length);
                let item = availableCells[itemIndex];

                showBlock(byId(item, IN_PROGRESS));
            }

            if (!foundSelected && cls === 'reset' && ALL_CELLS.some(c => isCellInProgress(c))) {
                for (let cell of getInProgressCells()) {
                    resetCell(cell);
                }
            }

            lockIrrelevantCells();
            determineNotInterestingCells();
        }

        function determineNotInterestingCells() {
            let interestingCells = getSelectedCells() + getInProgressCells();

            for (let cellId of ALL_CELLS) {
                let cell = byId(cellId);

                if (interestingCells.length === 0) {
                    cell.classList.remove(nonInterestingCls)
                    continue;
                }

                if (!isCellSelected(cellId) && !isCellInProgress(cellId) && !isCellHasResult(cellId)) {
                    cell.classList.add(nonInterestingCls);
                } else {
                    cell.classList.remove(nonInterestingCls);
                }
            }
        }

        function lockIrrelevantCells() {
            if (!isLockingSupported || !isLockCharts) {
                return;
            }

            for (let cellId of ALL_CELLS) {
                if (isCellLocked(cellId)) {
                    unlockCell(cellId);
                }

                if (isCellEmpty(cellId) ||
                    isCellHasResult(cellId) ||
                    isCellInProgress(cellId)) {
                    continue;
                }

                let rowLock = false;
                let colLock = false;
                let diagLock = false;

                let sameRow = getCellsSameRow(cellId);

                if (sameRow.some(c => isCellBlueWin(c)) &&
                    sameRow.some(c => isCellRedWin(c))) {
                    rowLock = true;
                }

                let sameCol = getCellsSameCol(cellId);

                if (sameCol.some(c => isCellBlueWin(c)) &&
                    sameCol.some(c => isCellRedWin(c))) {
                    colLock = true;
                }

                if (isDiagonalCell(cellId)) {
                    let diagonalCells = getDiagonalCells(cellId);

                    if (diagonalCells.some(c => isCellBlueWin(c)) &&
                        diagonalCells.some(c => isCellRedWin(c))) {
                        diagLock = true;
                    }
                } else {
                    diagLock = true;
                }

                if (rowLock && colLock && diagLock) {
                    lockCell(cellId);
                }
            }
        }

        function unlockAllCells() {
            ALL_CELLS
                .filter(c => isCellLocked(c))
                .forEach(c => unlockCell(c));
        }

        let downloadedImage = null;
        let downloadStart = null;

        function writeChartInfoToCell(cellId, chart) {
            makeNewCell(cellId);

            let cell = byId(cellId);
            let songname = byId(cellId, RANDOM_SONG);
            let cutname = byId(cellId, RANDOM_CUT);
            let diffname = byId(cellId, RANDOM_DIFFICULTY);

            let name = chart.name;
            if (name in shortened) {
                name = shortened[name];
            }

            songname.innerHTML = name;
            songname.style['font-size'] = '';

            if (chart.name in fontchange) {
                songname.style['font-size'] = fontchange[chart.name];
            }

            cutname.innerHTML = chart.cut;
            diffname.innerHTML = chart.diff;

            if (chart.single) {
                diffname.classList.add("single");
            }
            if (chart.double) {
                diffname.classList.add("double");
            }
            if (chart.performance) {
                diffname.classList.add("performance");
            }
            if (chart.coop) {
                diffname.classList.add("coop");
            }

            let card = useHighResImages ? chart.cardBig : chart.card;

            cell.style['background-image'] = "url(" + card + ")";
            downloadedImage = card;
            downloadStart = Date.now();

            selectedCharts.push(chart.chartId);
            cellsToCharts[cellId] = chart.chartId;
            chartIdToChart[chart.chartId] = chart;
        }

        function makeNewCell(cellId) {
            resetCell(cellId);

            let cell = byId(cellId);
            let songname = byId(cellId, RANDOM_SONG);
            let cutname = byId(cellId, RANDOM_CUT);
            let diffname = byId(cellId, RANDOM_DIFFICULTY);

            diffname.classList.remove("single");
            diffname.classList.remove("double");
            diffname.classList.remove("performance");
            diffname.classList.remove("coop");

            if (songname.innerHTML === '') {
                return;
            }

            let chartId = cellsToCharts[cellId];
            selectedCharts.splice(selectedCharts.indexOf(chartId), 1);
            cellsToCharts[cellId] = null;

            songname.innerHTML = '';
            songname.style['font-size'] = '';
            cutname.innerHTML = '';
            diffname.innerHTML = '';
            cell.style['background-image'] = "";
        }

        function clearTable() {
            resetSettings();

            for (let cellId of ALL_CELLS) {
                makeNewCell(cellId);
            }
        }

    </script>

</div>