<html lang="en" xmlns:th="http://www.thymeleaf.org">

<div th:fragment="bingo">

    <div id="field" class="field"></div>

    <script id="song-list" type="text/javascript" th:inline="javascript">
        let songs = [];
        const mixes = [[${mixes}]];
        const defaultMix = [[${defaultMix}]];

        let rows = [[${rows}]];
        let columns = [[${columns}]];
        let width = [[${width}]];
        let height = [[${height}]];
    </script>

    <script id="basic-functions" type="text/javascript">
        const BLUE_WIN = "bluewin";
        const RED_WIN = "redwin";
        const DRAW = "draw";
        const SELECTED = "selected";
        const IN_PROGRESS = "inprogress";
        const LOCKED = "lock";

        const TYPE_NAMES = "names";
        const NAMES_PLAYER_1 = "p1name";
        const NAMES_PLAYER_2 = "p2name";

        const TYPE_PLAYABLE = "playable";
        const RANDOM_BACKGROUND = "background";
        const RANDOM_SONG = "song";
        const RANDOM_CUT = "cut";
        const RANDOM_DIFFICULTY = "diff";

        const TYPE_EMPTY = "empty";

        const TYPE_TEXT = "text";
        const TEXT_INNER = "textinner";

        const TYPE_RANDOMIZER = "randomizer";
        const RANDOMIZER_TEXT = "randomizertext";
        const RANDOMIZER_ICON = "randomizericon";
        const RANDOMIZER_ICON_SPAN = "randomizericonspan";


        const OVERLAYS = [
            BLUE_WIN,
            RED_WIN,
            DRAW,
            SELECTED,
            IN_PROGRESS,
            LOCKED,
        ];

        const CELL_TYPES = [
            TYPE_NAMES,
            TYPE_PLAYABLE,
            TYPE_EMPTY,
            TYPE_RANDOMIZER,
        ];

        function isShowingBlock(block) {
            return block.style.display === 'block' || block.style.display === 'flex'
        }

        function showBlock(block, saveOverlay=true) {
            if (block.id.endsWith(RED_WIN) ||
                block.id.endsWith(BLUE_WIN) ||
                block.id.endsWith(TYPE_TEXT)
            ) {
                block.style.display = 'flex';
            } else {
                block.style.display = 'block';
            }

            let overlayArray = OVERLAYS.filter(e => block.id.endsWith(e));
            if (saveOverlay && overlayArray.length === 1) {
                let cellId = extractCellId(block.id);
                let overlay = overlayArray[0];

                let currOverlays = field_configuration.cells[cellId].overlays;
                if (!currOverlays) {
                    currOverlays = [];
                }

                if (!currOverlays.includes(overlay)) {
                    currOverlays.push(overlay);
                }

                field_configuration.cells[cellId].overlays = currOverlays;
            }
        }

        function byId(cellId, addon, extra) {
            if (addon && extra) {
                return document.getElementById(getBlockId(cellId, addon, extra));
            }
            if (addon) {
                return document.getElementById(getBlockId(cellId, addon));
            }
            return document.getElementById(cellId);
        }

        function hideBlock(block) {
            block.style.display = '';

            let overlayArray = OVERLAYS.filter(e => block.id.endsWith(e));
            if (overlayArray.length === 1) {
                let cellId = extractCellId(block.id);
                let overlay = overlayArray[0];

                let currOverlays = field_configuration.cells[cellId].overlays;
                if (!currOverlays) {
                    return;
                }

                let index = currOverlays.indexOf(overlay);
                if (index >= 0) {
                    currOverlays.splice(index, 1);
                }

                if (currOverlays.length === 0) {
                    delete field_configuration.cells[cellId].overlays;
                } else {
                    field_configuration.cells[cellId].overlays = currOverlays;
                }
            }
        }

        function getBlock(cellId, addon, extra) {
            return byId(getBlockId(cellId, addon, extra));
        }

        function getBlockId(cellId, addon, extra) {
            if (extra) {
                return `${cellId}-${addon}-${extra}`
            }
            return `${cellId}-${addon}`;
        }

        function getCell(row, col) {
            return byId(getCellId(row, col));
        }

        function getCellId(row, col) {
            return `${row}-${col}`;
        }

        function extractCellId(blockId) {
            let parts = blockId.split('-');
            return parts.slice(0, 2).join('-');
        }

        function getCellRow(cellId) {
            return parseInt(cellId.split('-')[0], 10);
        }

        function getCellColumn(cellId) {
            return parseInt(cellId.split('-')[1], 10);
        }
    </script>

    <script id="generate-cells" type="text/javascript" th:inline="javascript">
        const ALL_CELLS = [];
        const cellsToCharts = {};
        const selectedCharts = [];
        const chartIdToChart = {};

        function isCenterNamesCell(row, col) {
            const centerRow = rows / 2 | 0;
            const centerCol = columns / 2 | 0;
            return rows > 1 && columns > 1 && row === centerRow && col === centerCol;
        }

        function emptyConfiguration() {
            return {
                field: {
                    rows: rows,
                    columns: columns,
                    width: width,
                    height: height,
                },
                cells: {

                },
                settings: {
                    lock_charts: true,
                    plus1_full_row: true,
                    plus1_full_col: true,
                    counter: 0,
                },
                variables: {
                    blue_name: "A",
                    red_name: "B",
                    blue_score: 0,
                    red_score: 0,
                },
            };
        }

        let field_configuration = emptyConfiguration();

        function isCellTypePlayable(row, col) {
            return isCellOfType(row, col, TYPE_PLAYABLE);
        }

        function isCellIdOfType(cellId, type) {
            return field_configuration.cells[cellId].type === type;
        }

        function isCellOfType(row, col, type) {
            return isCellIdOfType(getCellId(row, col), type);
        }

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < columns; col++) {
                let cellId = getCellId(row, col);
                if (isCenterNamesCell(row, col)) {
                    field_configuration.cells[cellId] = {
                        type: TYPE_NAMES
                    }
                } else {
                    field_configuration.cells[cellId] = {
                        type: TYPE_PLAYABLE
                    }
                }
            }
        }

        function clearCellObjects() {
            ALL_CELLS.length = 0;
            selectedCharts.length = 0;

            for (const key in cellsToCharts) {
                if (cellsToCharts.hasOwnProperty(key)) {
                    delete cellsToCharts[key];
                }
            }

            for (const key in chartIdToChart) {
                if (chartIdToChart.hasOwnProperty(key)) {
                    delete chartIdToChart[key];
                }
            }
        }

        function generateCellObjects() {
            clearCellObjects();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < columns; c++) {
                    let cellId = getCellId(r, c);
                    if (isCellTypePlayable(r, c)) {
                        ALL_CELLS.push(cellId);
                        cellsToCharts[cellId] = null;
                    }
                }
            }
        }

        function generateField() {
            rows = field_configuration.field.rows;
            columns = field_configuration.field.columns;
            width = field_configuration.field.width;
            height = field_configuration.field.height;

            let fieldHtml = ``;

            for (let row = 0; row < rows; row++) {
                fieldHtml += `<div id="${row}" class="row">`;

                for (let col = 0; col < columns; col++) {
                    let cellId = getCellId(row, col);
                    fieldHtml += `
                        <div id="${cellId}" class="cell" onclick="clicked(this.id)" style="width: ${width}px; height: ${height}px">
                            <div id="${getBlockId(cellId, TYPE_PLAYABLE)}" class="filler cellinfo" style="background-size: 100% 100%;">
                                <div id="${getBlockId(cellId, RANDOM_BACKGROUND)}" class="song_background">
                                    <div id="${getBlockId(cellId, RANDOM_SONG)}" class="songname"></div>
                                    <div id="${getBlockId(cellId, RANDOM_CUT)}" class="cutname"></div>
                                    <div id="${getBlockId(cellId, RANDOM_DIFFICULTY)}" class="diffname"></div>
                                </div>
                            </div>

                            <div id="${getBlockId(cellId, TYPE_NAMES)}" class="filler players_names">
                                <div id="${getBlockId(cellId, NAMES_PLAYER_1)}" class="p1"></div>
                                <div id="${getBlockId(cellId, NAMES_PLAYER_2)}" class="p2"></div>
                            </div>

                            <div id="${getBlockId(cellId, TYPE_RANDOMIZER)}" class="filler randomizer">
                                <div id="${getBlockId(cellId, RANDOMIZER_TEXT)}" class="randomizer_text"></div>
                                <div id="${getBlockId(cellId, RANDOMIZER_ICON)}" class="randomizer_icon">
                                    <span id="${getBlockId(cellId, RANDOMIZER_ICON_SPAN)}">тно</span>
                                </div>
                            </div>

                            <div id="${getBlockId(cellId, BLUE_WIN)}" class="filler blue"></div>
                            <div id="${getBlockId(cellId, RED_WIN)}" class="filler red"></div>
                            <div id="${getBlockId(cellId, DRAW)}" class="filler draw"></div>
                            <div id="${getBlockId(cellId, SELECTED)}" class="filler selected"></div>
                            <div id="${getBlockId(cellId, IN_PROGRESS)}" class="filler inprogress"></div>
                            <div id="${getBlockId(cellId, LOCKED)}" class="filler lock"></div>

                            <div id="${getBlockId(cellId, TYPE_EMPTY)}" class="filler empty"></div>
                        </div>
                    `;
                }

                fieldHtml += `</div>`;
            }

            byId("field").innerHTML = fieldHtml;

            generateCellObjects();

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < columns; c++) {
                    let cellId = getCellId(r, c);
                    let cell = byId(cellId);
                    let cellConfig = field_configuration.cells[cellId];
                    cell.classList.remove("playable_cell");
                    cell.classList.remove("non_playable_cell");

                    if (isCellTypePlayable(r, c)) {
                        cell.classList.add("playable_cell");

                        showBlock(byId(cellId, TYPE_PLAYABLE));
                        let chart = cellConfig.chart;
                        if (chart) {
                            writeChartInfoToCell(cellId, chart);
                        }
                    } else {
                        cell.classList.add("non_playable_cell");

                        if (isCellOfType(r, c, TYPE_NAMES)) {
                            showBlock(byId(cellId, TYPE_NAMES));
                        } else if (isCellOfType(r, c, TYPE_EMPTY)) {
                            showBlock(byId(cellId, TYPE_EMPTY));
                        } else if (isCellOfType(r, c, TYPE_RANDOMIZER)) {
                            showBlock(byId(cellId, TYPE_RANDOMIZER));
                            randomizerCellConfigure(cellId, cellConfig);

                            byId(cellId, RANDOMIZER_ICON_SPAN).addEventListener('click', function(event) {
                                event.stopPropagation();
                                randomizeCellReroll(cellId, cellConfig);
                            });
                        }
                    }

                    if (cellConfig.overlays) {
                        for (let o of cellConfig.overlays) {
                            showBlock(byId(getBlockId(cellId, o)));
                        }
                    }

                    if (cellConfig.components) {
                        for (let config of cellConfig.components) {
                            if (config.type === TYPE_TEXT) {
                                cell.appendChild(createTextCell(cellId, config));
                                textCellConfigure(cellId, config);
                            }
                        }
                    }
                }
            }

            if (isNamesSupported) {
                if (field_configuration.variables.blue_name && field_configuration.variables.red_name) {
                    set_names(field_configuration.variables.blue_name, field_configuration.variables.red_name);
                }
            }

            if (isLockingSupported) {
                setLockCharts(field_configuration.settings.lock_charts);
            }

            lockIrrelevantCells();
            determineNotInterestingCells();
        }

        window.addEventListener("load", generateField);
    </script>


    <script th:if="${altLayout}" src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
    <script th:if="${altLayout}" type="text/javascript" th:inline="javascript">
        {
            let loader = `
                <div id="loader">
                    <div id="loader-bar"></div>
                    <div class="sk-cube-grid">
                        <div class="sk-cube sk-cube-1">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-2">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-3">
                            <div class="red-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-4">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-5">
                            <div class="yellow-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-6">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-7">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="sk-cube-na sk-cube-8">
                            <div class="grey-inner"></div>
                        </div>
                        <div class="sk-cube sk-cube-9">
                            <div class="blue-inner"></div>
                        </div>
                        <div class="back"></div>
                    </div>
                </div>`;

            window.addEventListener("load", () => {
                let elem = getCell(0, 0);
                elem.innerHTML = loader + elem.innerHTML;
            });
        }

        function rs() {
            let WDT = $(".row").width() -45,
                HGH = WDT*9 / 16;

            $("#settings").width(WDT);
            $("hr").width(WDT-30);
            $("#random").width(WDT-30);

            let e = getCell(0, 0);
            e.style["width"] = WDT + "px";
            e.style["height"] = HGH + "px";

            let inner = byId(getCellId(0, 0), TYPE_PLAYABLE);
            inner.style["width"] = "100%";
            inner.style["height"] = "100%";
        }

        window.addEventListener('load', rs);
        window.addEventListener('resize', rs);

        function loader(){
            if (includeNoLoader && isNoLoader) {
                return;
            }

            $("#loader").css({
                "display":"flex"
            });
            $(".diffname").css({
                "display":"none"
            });

            let updateLoaderFunc = function(){
                if (downloadedImage === null) {
                    $("#loader").css({
                        "display":"none"
                    });
                    $(".diffname").css({
                        "display":"block"
                    });
                    $("#loader-bar").css({
                        "width":"0%"
                    });
                } else {
                    setTimeout(updateLoaderFunc, 10);
                }
            }

            setTimeout(updateLoaderFunc, 2000);
        }
    </script>

    <script type="text/javascript" th:inline="javascript">

        const nonInterestingCls = "non-interesting";
        const determinedCls = "determined";

        const shortened = {
            "Can-can ~Orpheus in The Party Mix~": "Can-Can ~OiTPM~",
            "FOUR SEASONS OF LONELINESS ver╬▓ feat. sariyajin": "FOUR SEASONS OF LONELINESS",
            "DESTRUCIMATE": "DESTRUCI- MATE",
            "The Quick Brown Fox Jumps Over The Lazy Dog": "TQBFJOTLD",
            "Hypnosis(SynthWulf Mix)": "Hypnosis (SynthWulf Mix)",
            "Nakakapagpabagabag": "Nakakapag- pabagabag",
            "Pneumonoultramicroscopicsilicovolcanoconiosis": "Pneumonoultra microscopicsilico volcanoconiosis",
        }

        const fontchange = {
            "Turkey March -Minimal Tunes-": "21px",
            "Meteo5cience": "21px",
            "Love is a danger zone (try to B.P.M.)": "21px",
            "Reminiscence": "21px",
            "Blaze emotion (Band version)": "21px",
            "Repeatorment Remix": "20px",
            "Indestructible": "21px",
            "Pneumonoultramicroscopicsilicovolcanoconiosis": "17px",
            "GOODBOUNCE": "20px",
        }

        function isPlayableSpaceSquare() {
            if (field_configuration.field.rows === 1 || field_configuration.field.columns === 1) {
                return false;
            }

            let prevLeft = -1;
            let prevRight = -1;

            for (let r = 0; r < rows; r++) {
                let currLeft = -1;
                let currRight = -1;
                for (let c = 0; c < columns; c++) {
                    if (isCellTypePlayable(r, c) || isCellOfType(r, c, TYPE_NAMES)) {
                        if (currLeft === -1 || currLeft > c) {
                            currLeft = c;
                        }
                        if (currRight === -1 || currRight < c) {
                            currRight = c;
                        }
                    }
                }

                if (currLeft !== -1 && currRight !== -1) {
                    if (prevLeft === -1) {
                        prevLeft = currLeft;
                    }
                    if (prevRight === -1) {
                        prevRight = currRight;
                    }
                    if (prevLeft !== currLeft) {
                        return false;
                    }
                    if (prevRight !== currRight) {
                        return false;
                    }
                }
            }

            let prevUp = -1;
            let prevDown = -1;

            for (let c = 0; c < columns; c++) {
                let currUp = -1;
                let currDown = -1;
                for (let r = 0; r < rows; r++) {
                    if (isCellTypePlayable(r, c) || isCellOfType(r, c, TYPE_NAMES)) {
                        if (currUp === -1 || currUp > r) {
                            currUp = r;
                        }
                        if (currDown === -1 || currDown < r) {
                            currDown = r;
                        }
                    }
                }

                if (currUp !== -1 && currDown !== -1) {
                    if (prevUp === -1) {
                        prevUp = currUp;
                    }
                    if (prevDown === -1) {
                        prevDown = currDown;
                    }
                    if (prevUp !== currUp) {
                        return false;
                    }
                    if (prevDown !== currDown) {
                        return false;
                    }
                }
            }

            return prevDown - prevUp === prevRight - prevLeft;
        }

        function isSquareField() {
            return isPlayableSpaceSquare();
        }

        function isNoSameLineForRow() {
            return isNoSameLineSupported && isNoSameLine && isSquareField();
        }

        function isNoSameLineForColumn() {
            return isNoSameLineSupported && isNoSameLine && isSquareField();
        }

        function isNoSameLineForDiagonals() {
            return isNoSameLineSupported && isNoSameLine && isSquareField();
        }

        function isMainDiagonalCell(cellId) {
            return isSquareField() && getCellRow(cellId) === getCellColumn(cellId);
        }

        function isSideDiagonalCell(cellId) {
            return isSquareField() && Number(getCellRow(cellId)) + Number(getCellColumn(cellId)) === rows - 1;
        }

        function isDiagonalCell(cellId) {
            return isMainDiagonalCell(cellId) || isSideDiagonalCell(cellId);
        }

        function getDiagonalCells(cellId) {
            if (isMainDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isMainDiagonalCell(c));
            } else if (isSideDiagonalCell(cellId)) {
                return ALL_CELLS.filter(c => c !== cellId && isSideDiagonalCell(c));
            }
            return undefined;
        }

        function getChosenCells() {
            let chosen = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < columns; c++) {
                    chosen.push(getCellId(r, c));
                }
            }
            return chosen.filter(c => isCellSelected(c));
        }

        function getSelectedCells() {
            return ALL_CELLS.filter(c => isCellSelected(c));
        }

        function getEmptyCells() {
            return ALL_CELLS.filter(c => isCellEmpty(c));
        }

        function isCellEmpty(cellId) {
            return cellsToCharts[cellId] === null;
        }

        function getInProgressCells() {
            return ALL_CELLS.filter(c => isCellInProgress(c));
        }

        function getCellsToChange() {
            let cellsToChange = getSelectedCells();
            if (cellsToChange.length > 0) {
                return cellsToChange;
            }

            let emptyCells = getEmptyCells();

            if (emptyCells.length > 0) {
                return emptyCells;
            }
            return getInProgressCells();
        }

        function getCandidatesCharts(for_preview) {
            let candidates = [];

            for (let song of songs) {
                next_chart:
                for (let chart of song.charts) {
                    if (!for_preview) {
                        if (selectedCharts.includes(chart.chart_id)) {
                            continue;
                        }
                    }

                    for (let filter of chartFilters) {
                        if (!filter(song, chart)) {
                            continue next_chart;
                        }
                    }

                    candidates.push({
                        songId: song.song_id,
                        chartId: chart.chart_id,
                        name: song.name,
                        diff: chart.difficulty.name,
                        diffNum: chart.difficulty.difficulty,
                        cut: includeCut ? get_simpler_cut(song.cut) : song.cut,
                        card: song.card,
                        cardBig: song.card_big,
                        single: chart.difficulty.single,
                        double: chart.difficulty.double,
                        performance: chart.difficulty.performance,
                        coop: chart.difficulty.coop,
                    });
                }
            }

            return candidates;
        }

        function shuffleCells(cells) {
            return cells
                .map(value => ({ value, sort: Math.random() }))
                .sort((a, b) => a.sort - b.sort)
                .map(({ value }) => value);
        }

        function hasChartInCell(cellId) {
            return !!cellsToCharts[cellId];
        }

        function getChartFromCell(cellId) {
            return chartIdToChart[cellsToCharts[cellId]];
        }

        function getChartsFromCells(cellsIds) {
            return cellsIds
                .map(c => cellsToCharts[c])
                .filter(c => c !== null)
                .map(c => chartIdToChart[c]);
        }

        function getCellsSameRow(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && getCellRow(c) === getCellRow(cellId));
        }

        function getCellsSameCol(cellId) {
            return ALL_CELLS.filter(c => c !== cellId && getCellColumn(c) === getCellColumn(cellId));
        }

        function doesMakeSameLine(cellId, wantSingle) {
            if (isNoSameLineForRow()) {
                let sameRowCells = getCellsSameRow(cellId);
                let sameRowCharts = getChartsFromCells(sameRowCells);

                if (sameRowCells.length === sameRowCharts.length && sameRowCells.length !== 0 &&
                    sameRowCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                    return true;
                }
            }

            if (isNoSameLineForColumn()) {
                let sameColCells = getCellsSameCol(cellId);
                let sameColCharts = getChartsFromCells(sameColCells);

                if (sameColCells.length === sameColCharts.length && sameColCells.length !== 0 &&
                    sameColCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                    return true;
                }
            }

             if (isNoSameLineForDiagonals()) {
                 if (isDiagonalCell(cellId)) {
                     let sameDiagonalCells = getDiagonalCells(cellId);
                     let sameDiagonalCharts = getChartsFromCells(sameDiagonalCells);

                     if (sameDiagonalCells.length === sameDiagonalCharts.length && sameDiagonalCells.length !== 0 &&
                         sameDiagonalCharts.every(c => wantSingle && c.single || !wantSingle && c.double)) {
                         return true;
                     }
                 }
             }

            return false;
        }

        function haveSameLineOnTable() {
            return ALL_CELLS.some(c => c !== null && hasChartInCell(c) && doesMakeSameLine(c, getChartFromCell(c).single));
        }

        function chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles) {
            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, true)) {
                return false;
            }
            if (isNoSameLineSupported && isNoSameLine && doesMakeSameLine(cellId, false)) {
                return true;
            }

            const simplePercents = true;

            if (simplePercents) {
                let totalSum = sumSingles + sumDoubles;
                if (totalSum === 0) {
                    let rand = Math.random();
                    return rand < singlePercentage;
                } else {
                    let currSinglePercentage = sumSingles / totalSum;

                    if (currSinglePercentage === singlePercentage) {
                        let rand = Math.random();
                        return rand < singlePercentage;
                    } else {
                        return currSinglePercentage < singlePercentage;
                    }
                }
            }


            // more complex algo, seems to be worse

            let totalSum = sumSingles + sumDoubles;
            let currSinglePercentage;
            let currDoublePercentage;

            if (totalSum === 0) {
                currSinglePercentage = 0.5;
                currDoublePercentage = 0.5;
            } else {
                currSinglePercentage = sumSingles / totalSum;
                currDoublePercentage = sumDoubles / totalSum;
            }

            let diffPercentage = currSinglePercentage - currDoublePercentage;

            let improvedSinglePercentage = singlePercentage - diffPercentage;

            let randomSingleDouble = Math.random();

            // returns true if chooses Singles, returns false if chooses Doubles
            return improvedSinglePercentage > randomSingleDouble;
        }

        function chooseDifficulty(sumDiff, sumAllDiff) {

            let useRobustRandomizer = true;

            if (useRobustRandomizer) {

                let shouldBeRandomized = {};
                let somethingShouldBeRandomized = false;
                let sumOffIdealPercentage = 0;
                let offIdealPercentageForDiff = {};
                let maxOffIdealPercentage = 0;

                for (let currDiff in sumDiff) {
                    if (sumAllDiff === 0) {
                        shouldBeRandomized[currDiff] = percents[currDiff] > 0;
                        continue;
                    }

                    let currentDiffPercent = sumDiff[currDiff] / sumAllDiff;
                    let offIdealPercentage = percents[currDiff] - currentDiffPercent;

                    let diffShouldBeRandomized = offIdealPercentage > 0;
                    shouldBeRandomized[currDiff] = diffShouldBeRandomized;

                    if (diffShouldBeRandomized) {
                        somethingShouldBeRandomized = true;
                        offIdealPercentageForDiff[currDiff] = offIdealPercentage;

                        if (offIdealPercentage > maxOffIdealPercentage) {
                            maxOffIdealPercentage = offIdealPercentage;
                            sumOffIdealPercentage = 0;
                        }

                        if (offIdealPercentage === maxOffIdealPercentage) {
                            sumOffIdealPercentage += offIdealPercentage;
                        }
                    }
                }

                let finalPercentagesDifficulties = {};

                if (!somethingShouldBeRandomized || sumAllDiff === 0) {
                    for (let currDiff in sumDiff) {
                        finalPercentagesDifficulties[currDiff] = percents[currDiff];
                    }
                } else  {
                    for (let currDiff in sumDiff) {
                        if (!shouldBeRandomized[currDiff]) {
                            finalPercentagesDifficulties[currDiff] = 0;
                            continue;
                        }
                        if (offIdealPercentageForDiff[currDiff] !== maxOffIdealPercentage) {
                            finalPercentagesDifficulties[currDiff] = 0;
                            continue;
                        }
                        finalPercentagesDifficulties[currDiff] = offIdealPercentageForDiff[currDiff] / sumOffIdealPercentage;
                    }
                }

                while (true) {
                    let randomDifficulty = Math.random();

                    for (let currDiff in finalPercentagesDifficulties) {
                        let currPercents = finalPercentagesDifficulties[currDiff];
                        randomDifficulty -= currPercents;
                        if (randomDifficulty < 0) {
                            return Number(currDiff);
                        }
                    }
                }
            }



            // old algo, more variativity
            let updatedPercentagesDifficulties = {};
            for (let currDiff in sumDiff) {
                if (sumAllDiff === 0) {
                    updatedPercentagesDifficulties[currDiff] = percents[currDiff];
                    continue;
                }

                let currDiffPercentage = sumDiff[currDiff] / sumAllDiff;
                let percentageDifference = currDiffPercentage - percents[currDiff];
                updatedPercentagesDifficulties[currDiff] = percents[currDiff] - percentageDifference;
            }

            while (true) {
                let randomDifficulty = Math.random();

                for (let currDiff in updatedPercentagesDifficulties) {
                    let currPercents = updatedPercentagesDifficulties[currDiff];
                    randomDifficulty -= currPercents;
                    if (randomDifficulty < 0) {
                        return Number(currDiff);
                    }
                }
            }

        }

        function filterCandidates(candidates, searchSingles, searchDoubles, chosenDifficulty, forceRandom) {
            let nonSelectedCandidates = candidates
                .filter(c => !selectedCharts.includes(c.chartId));

            let filteredCandidates = nonSelectedCandidates
                .filter(c =>
                    (c.single && searchSingles || c.double && searchDoubles) &&
                    c.diffNum === chosenDifficulty ||
                    c.coop
                );

            if (filteredCandidates.length === 0 && forceRandom) {
                filteredCandidates = nonSelectedCandidates
            }

            return filteredCandidates;
        }

        function randomize() {
            let cellsToChange = shuffleCells(getCellsToChange());
            let candidates = getCandidatesCharts(false);

            let sumSingles = 0;
            let sumDoubles = 0;
            let sumDiff = {};
            let sumAllDiff = 0;
            for (let perc in percents) {
                sumDiff[perc] = 0;
            }

            let cannotRandomizeCellSameLine = false;
            let randomizedCharts = [];

            cellIdFor:
            for (let cellId of cellsToChange) {
                if (candidates.length === 0) {
                    return;
                }

                let searchSingles;
                let searchDoubles;
                let finalCandidates = [];

                let counter = 0;
                while (true) {
                    counter++;

                    searchSingles = isSingle;
                    searchDoubles = isDouble;

                    if (isCoop) {
                        searchSingles = false;
                        searchDoubles = false;
                    }

                    if (isNoSameLineSupported && isNoSameLine) {
                        if (isSingle && doesMakeSameLine(cellId, true) &&
                            isDouble && doesMakeSameLine(cellId, false)) {
                            cannotRandomizeCellSameLine = true;
                            continue cellIdFor;
                        }
                    }

                    if (isSingle && isDouble) {
                        searchSingles = chooseSinglesOrDoubles(cellId, sumSingles, sumDoubles);
                        searchDoubles= !searchSingles;
                    } else if (isNoSameLineSupported && isNoSameLine) {
                        if (isSingle && !isDouble && doesMakeSameLine(cellId, true) ||
                            isDouble && !isSingle && doesMakeSameLine(cellId, false)) {
                            cannotRandomizeCellSameLine = true;
                            continue cellIdFor;
                        }
                    }

                    let chosenDifficulty = chooseDifficulty(sumDiff, sumAllDiff);

                    let forceChoose = counter === 1000;

                    finalCandidates = filterCandidates(
                        candidates, searchSingles, searchDoubles, chosenDifficulty, forceChoose);

                    if (finalCandidates.length !== 0 || forceChoose) {
                        break;
                    }
                }

                if (finalCandidates.length === 0) {
                    break;
                }

                let itemIndex = Math.floor(Math.random() * finalCandidates.length);
                let item = finalCandidates[itemIndex];

                if (item.single) {
                    sumSingles++;
                }

                if (item.double) {
                    sumDoubles++;
                }

                sumAllDiff++;
                if (item.diffNum in sumDiff) {
                    sumDiff[item.diffNum]++;
                }

                writeChartInfoToCell(cellId, item);
                randomizedCharts.push(item);
            }

            if (initialRandomize && cannotRandomizeCellSameLine) {
                clearTable();
                randomize();
                return;
            }

            if (initialRandomize && isNoSameLineSupported && isNoSameLine && haveSameLineOnTable()) {
                clearTable();
                randomize();
                return;
            }

            if (initialRandomize) {
                initialRandomize = false;
            }

            if (isNoSameLineSupported) {
                handleRedNoSameLineText(cannotRandomizeCellSameLine);
            }

            lockIrrelevantCells();
            determineNotInterestingCells();

            for (let chart of randomizedCharts) {
                if (includeNoRepeat) {
                    process_no_repeat(chart);
                }
                if (includePreview) {
                    update_preview(getCandidatesCharts(true));
                }
            }
        }

        function clicked(cellId) {
            if (isConfigurationEnabled && !isConfigurationVisible() && !isCellIdOfType(cellId, TYPE_PLAYABLE)) {
                return;
            }

            let selectedDiv = byId(cellId, SELECTED);
            let showing = isShowingBlock(selectedDiv);

            let chosen =  getChosenCells();

            if (!isCtrlPressed) {
                getChosenCells().forEach(cellId => hideBlock(byId(cellId, SELECTED)));
                if (chosen.length > 1) {
                    showBlock(selectedDiv);
                } else {
                    if (showing) {
                        hideBlock(selectedDiv);
                    } else {
                        showBlock(selectedDiv);
                    }
                }
            } else {
                if (showing) {
                    hideBlock(selectedDiv);
                } else {
                    showBlock(selectedDiv);
                }
            }

            determineNotInterestingCells();

            if (isConfigurationEnabled) {
                configureOnSelect();
            }
        }

        function isCellSelected(cellId) {
            let selected = byId(cellId, SELECTED);
            return isShowingBlock(selected);
        }

        function isCellInProgress(cellId) {
            let inprogress = byId(cellId, IN_PROGRESS);
            return isShowingBlock(inprogress);
        }

        function isCellLocked(cellId) {
            let lock = byId(cellId, LOCKED);
            return isShowingBlock(lock);
        }

        function lockCell(cellId) {
            let lock = byId(cellId, LOCKED);
            showBlock(lock);

            let cell = byId(cellId);
            cell.classList.add("locked");
        }

        function unlockCell(cellId) {
            let lock = byId(cellId, LOCKED);
            hideBlock(lock);

            let cell = byId(cellId);
            cell.classList.remove("locked");
        }

        function isCellHasResult(cellId) {
            let blue = byId(cellId, BLUE_WIN);
            let red = byId(cellId, RED_WIN);
            let draw = byId(cellId, DRAW);
            return isShowingBlock(blue) || isShowingBlock(red) || isShowingBlock(draw);
        }

        function isCellBlueWin(cellId) {
            let blue = byId(cellId, BLUE_WIN);
            return isShowingBlock(blue);
        }

        function isCellRedWin(cellId) {
            let red = byId(cellId, RED_WIN);
            return isShowingBlock(red);
        }

        function resetCell(cellId) {
            unlockCell(cellId);

            let cell = byId(cellId, TYPE_PLAYABLE);
            cell.classList.remove(determinedCls);
            cell.classList.remove(nonInterestingCls);

            for (let overlay of OVERLAYS) {
                let item = byId(cellId, overlay);
                if (isShowingBlock(item)) {
                    hideBlock(item);
                }
            }
        }

        function changeCellState(cls) {
            let selectedOrInProgress = ALL_CELLS.filter(c => isCellInProgress(c) || isCellSelected(c));
            if (combineInProgressAndSelected && cls === IN_PROGRESS && selectedOrInProgress.length > 1) {

                let itemIndex = Math.floor(Math.random() * selectedOrInProgress.length);
                let item = selectedOrInProgress[itemIndex];

                showBlock(byId(item, SELECTED));

                selectedOrInProgress
                    .filter(s => s !== item)
                    .forEach(s => {
                        hideBlock(byId(s, SELECTED));
                        hideBlock(byId(s, IN_PROGRESS));
                    });

                determineNotInterestingCells();
                return;
            }

            let foundSelected = false;
            const isDetermination = [RED_WIN, BLUE_WIN, DRAW].includes(cls);

            for (let cellId of ALL_CELLS) {
                if (!isCellSelected(cellId)) {
                    continue;
                }

                foundSelected = true;

                if (cls !== 'reset') {
                    if (combineInProgressAndSelected && cls === IN_PROGRESS) {
                        if (isConfigurationEnabled) {
                            handleResettingCellFromWinning(cellId);
                        }
                        resetCell(cellId);
                        showBlock(byId(cellId, SELECTED));
                    } else {
                        let block = byId(cellId, cls);
                        if (isConfigurationEnabled && !isShowingBlock(block)) {
                            handleWinningCell(cellId, cls);
                        }
                        resetCell(cellId);
                        showBlock(block);
                    }

                    if (isDetermination) {
                        byId(cellId, TYPE_PLAYABLE).classList.add(determinedCls);
                    }
                } else {
                    if (isConfigurationEnabled) {
                        handleResettingCellFromWinning(cellId);
                    }
                    resetCell(cellId);
                }
            }

            if (!foundSelected && isDetermination) {
                for (let cellId of ALL_CELLS) {
                    if (isCellInProgress(cellId)) {
                        let block = byId(cellId, cls);
                        if (isConfigurationEnabled && !isShowingBlock(block)) {
                            handleWinningCell(cellId, cls);
                        }
                        resetCell(cellId);
                        showBlock(block);
                        byId(cellId, TYPE_PLAYABLE).classList.add(determinedCls);
                    }
                }
            }

            outerIf:
            if (!foundSelected && cls === IN_PROGRESS &&
                ALL_CELLS.every(c => !isCellInProgress(c))) {

                let availableCells = ALL_CELLS
                    .filter(c => !isCellHasResult(c) && !isCellLocked(c));

                if (availableCells.length === 0) {
                    break outerIf;
                }

                let itemIndex = Math.floor(Math.random() * availableCells.length);
                let item = availableCells[itemIndex];

                if (combineInProgressAndSelected) {
                    showBlock(byId(item, SELECTED));
                } else {
                    showBlock(byId(item, IN_PROGRESS));
                }
            }

            if (!foundSelected && cls === 'reset' && ALL_CELLS.some(c => isCellInProgress(c))) {
                for (let cellId of getInProgressCells()) {
                    if (isConfigurationEnabled) {
                        handleResettingCellFromWinning(cellId);
                    }
                    resetCell(cellId);
                }
            }

            lockIrrelevantCells();
            determineNotInterestingCells();
        }

        function determineNotInterestingCells() {
            let interestingCells = getSelectedCells() + getInProgressCells();

            for (let cellId of ALL_CELLS) {
                let cell = byId(cellId, TYPE_PLAYABLE);

                if (interestingCells.length === 0) {
                    cell.classList.remove(nonInterestingCls)
                    continue;
                }

                if (!isCellSelected(cellId) && !isCellInProgress(cellId) && !isCellHasResult(cellId) && !isCellEmpty(cellId)) {
                    cell.classList.add(nonInterestingCls);
                } else {
                    cell.classList.remove(nonInterestingCls);
                }
            }
        }

        function lockIrrelevantCells() {
            if (!isLockingSupported || !isLockCharts) {
                return;
            }

            for (let cellId of ALL_CELLS) {
                if (isCellLocked(cellId)) {
                    unlockCell(cellId);
                }

                if (isCellEmpty(cellId) ||
                    isCellHasResult(cellId) ||
                    isCellInProgress(cellId)) {
                    continue;
                }

                let rowLock = false;
                let colLock = false;
                let diagLock = false;

                let sameRow = getCellsSameRow(cellId);

                if (sameRow.some(c => isCellBlueWin(c)) &&
                    sameRow.some(c => isCellRedWin(c))) {
                    rowLock = true;
                }

                let sameCol = getCellsSameCol(cellId);

                if (sameCol.some(c => isCellBlueWin(c)) &&
                    sameCol.some(c => isCellRedWin(c))) {
                    colLock = true;
                }

                if (isDiagonalCell(cellId)) {
                    let diagonalCells = getDiagonalCells(cellId);

                    if (diagonalCells.some(c => isCellBlueWin(c)) &&
                        diagonalCells.some(c => isCellRedWin(c))) {
                        diagLock = true;
                    }
                } else {
                    diagLock = true;
                }

                if (rowLock && colLock && diagLock) {
                    lockCell(cellId);
                }
            }
        }

        function unlockAllCells() {
            ALL_CELLS
                .filter(c => isCellLocked(c))
                .forEach(c => unlockCell(c));
        }

        let downloadedImage = null;
        let downloadStart = null;

        function writeChartInfoToCell(cellId, chart) {
            makeNewCell(cellId);

            let cell = byId(cellId, TYPE_PLAYABLE);
            let songname = byId(cellId, RANDOM_SONG);
            let cutname = byId(cellId, RANDOM_CUT);
            let diffname = byId(cellId, RANDOM_DIFFICULTY);

            let name = chart.name;
            if (name in shortened) {
                name = shortened[name];
            }

            songname.innerHTML = name;
            songname.style['font-size'] = '';

            if (chart.name in fontchange) {
                songname.style['font-size'] = fontchange[chart.name];
            }

            cutname.innerHTML = chart.cut;
            diffname.innerHTML = chart.diff;

            if (chart.single) {
                diffname.classList.add("single");
            }
            if (chart.double) {
                diffname.classList.add("double");
            }
            if (chart.performance) {
                diffname.classList.add("performance");
            }
            if (chart.coop) {
                diffname.classList.add("coop");
            }

            let card = useHighResImages ? chart.cardBig : chart.card;

            cell.style['background-image'] = "url(" + card + ")";
            downloadedImage = card;
            downloadStart = Date.now();

            selectedCharts.push(chart.chartId);
            cellsToCharts[cellId] = chart.chartId;
            chartIdToChart[chart.chartId] = chart;

            field_configuration.cells[cellId].chart = chart;
        }

        function makeNewCell(cellId) {
            resetCell(cellId);

            let cell = byId(cellId, TYPE_PLAYABLE);
            let songname = byId(cellId, RANDOM_SONG);
            let cutname = byId(cellId, RANDOM_CUT);
            let diffname = byId(cellId, RANDOM_DIFFICULTY);

            diffname.classList.remove("single");
            diffname.classList.remove("double");
            diffname.classList.remove("performance");
            diffname.classList.remove("coop");

            if (songname.innerHTML === '') {
                return;
            }

            let chartId = cellsToCharts[cellId];
            selectedCharts.splice(selectedCharts.indexOf(chartId), 1);
            cellsToCharts[cellId] = null;

            if (field_configuration.cells[cellId].chart) {
                delete field_configuration.cells[cellId].chart;
            }

            songname.innerHTML = '';
            songname.style['font-size'] = '';
            cutname.innerHTML = '';
            diffname.innerHTML = '';
            cell.style['background-image'] = "";
        }

        function clearTable() {
            resetSettings();

            if (isConfigurationEnabled) {
                updateVariableValue('blue_score', () => 0);
                updateVariableValue('red_score', () => 0);
            }

            for (let cellId of ALL_CELLS) {
                makeNewCell(cellId);
            }
        }

    </script>

</div>